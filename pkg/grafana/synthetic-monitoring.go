package grafana

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"

	"github.com/grafana/grizzly/pkg/grizzly"
	"github.com/mitchellh/mapstructure"
)

/*
 * @TODO
 * 1. The API does not have a GET method, so we have to fake it here
 * 2. The API expects an ID and a tenantId in an update, but these are
 *    generated by the server so cannot be represented in Jsonnet.
 *    Therefore, we have to pre-retrieve the check to get those values
 *    so we can inject them before posting JSON.
 * 3. This means pre-retrieving the check *twice*, once to establish
 *    whether this resource has changed or not (within Grizzly ifself)
 *    and again within this provider to retrieve IDs. Not ideal.
 */

const smURL = "https://synthetic-monitoring-api.grafana.net/%s"

// SyntheticMonitoringProvider is a Grizzly Provider for Grafana Synthetic Monitoring
type SyntheticMonitoringProvider struct{}

// NewSyntheticMonitoringProvider returns configuration defining a new Grafana Provider
func NewSyntheticMonitoringProvider() *SyntheticMonitoringProvider {
	return &SyntheticMonitoringProvider{}
}

// GetName returns the name for this provider
func (p *SyntheticMonitoringProvider) GetName() string {
	return "grafana"
}

// GetJSONPath returns a paths within Jsonnet output that this provider will consume
func (p *SyntheticMonitoringProvider) GetJSONPath() string {
	return "syntheticMonitoring"
}

// GetExtension returns the file name extension for a check
func (p *SyntheticMonitoringProvider) GetExtension() string {
	return "json"
}

func (p *SyntheticMonitoringProvider) newCheckResource(filename string, check Check) grizzly.Resource {
	resource := grizzly.Resource{
		UID:      check.UID(),
		Filename: filename,
		Provider: p,
		Detail:   check,
		Path:     p.GetJSONPath(),
	}
	return resource
}

// Parse parses an interface{} object into a struct for this resource type
func (p *SyntheticMonitoringProvider) Parse(i interface{}) (grizzly.Resources, error) {
	resources := grizzly.Resources{}
	msi := i.(map[string]interface{})
	for k, v := range msi {
		check := Check{}
		err := mapstructure.Decode(v, &check)
		if err != nil {
			return nil, err
		}
		resource := p.newCheckResource(k, check)
		key := resource.Key()
		resources[key] = resource
	}
	return resources, nil
}

// GetByUID retrieves JSON for a resource from an endpoint, by UID
func (p *SyntheticMonitoringProvider) GetByUID(UID string) (*grizzly.Resource, error) {
	check, err := getRemoteCheck(UID)
	if err != nil {
		return nil, fmt.Errorf("Error retrieving check %s: %v", UID, err)
	}
	resource := p.newCheckResource("", *check)
	return &resource, nil
}

// GetRepresentation renders a resource as JSON or YAML as appropriate
func (p *SyntheticMonitoringProvider) GetRepresentation(uid string, detail map[string]interface{}) (string, error) {
	j, err := json.MarshalIndent(detail, "", "  ")
	if err != nil {
		return "", err
	}
	return string(j), nil
}

// GetRemoteRepresentation retrieves a datasource as JSON
func (p *SyntheticMonitoringProvider) GetRemoteRepresentation(uid string) (string, error) {
	check, err := getRemoteCheck(uid)
	if err != nil {
		return "", err
	}
	delete(*check, "tenantId")
	delete(*check, "id")
	return check.toJSON()
}

// Apply pushes a datasource to Grafana via the API
func (p *SyntheticMonitoringProvider) Apply(detail map[string]interface{}) error {
	check := Check(detail)

	uid := check.UID()
	existingCheck, err := getRemoteCheck(uid)

	switch err {
	case grizzly.ErrNotFound: // create new
		if err := addCheck(check); err != nil {
			return err
		}
		fmt.Println(uid, grizzly.Green("added"))

	case nil: // update
		checkJSON, _ := check.toJSON()
		existingCheckJSON, _ := existingCheck.toJSON()

		if checkJSON == existingCheckJSON {
			fmt.Println(uid, grizzly.Yellow("unchanged"))
			return nil
		}

		if err = updateCheck(check); err != nil {
			return err
		}
		fmt.Println(uid, grizzly.Green("updated"))

	default: // failed
		return fmt.Errorf("Error retrieving check %s: %v", uid, err)
	}
	return nil
}

// Preview renders Jsonnet then pushes them to the endpoint if previews are possible
func (p *SyntheticMonitoringProvider) Preview(detail map[string]interface{}) error {
	return nil
}

///////////////////////////////////////////////////////////////////////////

// getRemoteCheck retrieves a check object from SM
func getRemoteCheck(uid string) (*Check, error) {
	url := getURL("api/v1/check/list")
	authToken, err := getAuthToken()
	if err != nil {
		return nil, err
	}
	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	req.Header.Add("Authorization", "Bearer "+authToken)
	req.Header.Add("Content-type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNotFound:
		return nil, grizzly.ErrNotFound
	default:
		if resp.StatusCode >= 400 {
			return nil, errors.New(resp.Status)
		}
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var checks []Check
	if err := json.Unmarshal(data, &checks); err != nil {
		return nil, APIErr{err, data}
	}
	for _, check := range checks {
		if check.UID() == uid {
			delete(check, "modified")
			delete(check, "created")
			return &check, nil
		}
	}
	return nil, grizzly.ErrNotFound
}

func addCheck(check Check) error {
	url := getURL("api/v1/check/add")
	return postCheck(url, check)
}

func updateCheck(check Check) error {
	existingCheck, err := getRemoteCheck(check.UID())
	if err != nil {
		return err
	}
	url := getURL("api/v1/check/update")
	check["tenantId"] = (*existingCheck)["tenantId"]
	check["id"] = (*existingCheck)["id"]
	return postCheck(url, check)
}

func postCheck(url string, check Check) error {
	checkJSON, err := check.toJSON()
	if err != nil {
		return err
	}

	client := &http.Client{}
	accessToken, err := getAuthToken()
	if err != nil {
		return err
	}
	req, err := http.NewRequest("POST", url, bytes.NewBufferString(checkJSON))
	if err != nil {
		return err
	}
	req.Header.Add("Authorization", "Bearer "+accessToken)
	req.Header.Add("Content-type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		return err
	}

	switch resp.StatusCode {
	case http.StatusOK:
		break
	default:
		return fmt.Errorf("Non-200 response from Grafana Synthetic Monitoring while applying '%s': %s", resp.Status, check.UID())
	}
	return nil
}

// Check encapsulates a check
type Check map[string]interface{}

// UID retrieves the UID from a check
func (c *Check) UID() string {
	job, ok := (*c)["job"]
	if !ok {
		return "X"
	}
	settings, ok := (*c)["settings"]
	if !ok {
		return "Y"
	}
	for typ := range settings.(map[string]interface{}) {
		return fmt.Sprintf("%s-%s", typ, job)
	}
	return "NIL"
}

// toJSON returns JSON for a datasource
func (c *Check) toJSON() (string, error) {
	j, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return "", err
	}
	return string(j), nil
}

func getURL(path string) string {
	return fmt.Sprintf(smURL, path)
}

func getAuthToken() (string, error) {
	url := getURL("api/v1/register/init")
	apiToken := os.Getenv("GRAFANA_SM_TOKEN")
	authRequest := fmt.Sprintf(`{"apiToken":"%s"}`, apiToken)

	resp, err := http.Post(url, "application/json", bytes.NewBufferString(authRequest))
	if err != nil {
		return "", err
	} else if resp.StatusCode >= 400 {
		return "", fmt.Errorf("%d response while authenticating", resp.StatusCode)
	}
	type AuthResponse struct {
		AccessToken string `json:"accessToken"`
	}
	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	authResponse := AuthResponse{}
	if err := json.Unmarshal(data, &authResponse); err != nil {
		return "", APIErr{err, data}

	}
	return authResponse.AccessToken, nil
}
