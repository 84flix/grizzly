package grafana

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"

	"github.com/grafana/grizzly/pkg/grizzly"
	"github.com/mitchellh/mapstructure"
)

/*
 * @TODO
 * 1. The API does not have a GET method, so we have to fake it here
 * 2. The API expects an ID and a tenantId in an update, but these are
 *    generated by the server so cannot be represented in Jsonnet.
 *    Therefore, we have to pre-retrieve the check to get those values
 *    so we can inject them before posting JSON.
 * 3. This means pre-retrieving the check *twice*, once to establish
 *    whether this resource has changed or not (within Grizzly ifself)
 *    and again within this provider to retrieve IDs. Not ideal.
 */

const smURL = "https://synthetic-monitoring-api.grafana.net/%s"

// SyntheticMonitoringHandler is a Grizzly Provider for Grafana Synthetic Monitoring
type SyntheticMonitoringHandler struct{}

// NewSyntheticMonitoringHandler returns configuration defining a new Grafana Provider
func NewSyntheticMonitoringHandler() *SyntheticMonitoringHandler {
	return &SyntheticMonitoringHandler{}
}

// GetName returns the name for this provider
func (h *SyntheticMonitoringHandler) GetName() string {
	return "synthetic-monitor"
}

// GetFullName returns the name for this provider
func (h *SyntheticMonitoringHandler) GetFullName() string {
	return "grafana.synthetic-monitor"
}

// GetJSONPath returns a paths within Jsonnet output that this provider will consume
func (h *SyntheticMonitoringHandler) GetJSONPath() string {
	return "syntheticMonitoring"
}

// GetExtension returns the file name extension for a check
func (h *SyntheticMonitoringHandler) GetExtension() string {
	return "json"
}

func (h *SyntheticMonitoringHandler) newCheckResource(filename string, check Check) grizzly.Resource {
	resource := grizzly.Resource{
		UID:      check.UID(),
		Filename: filename,
		Handler:  h,
		Detail:   check,
		Path:     h.GetJSONPath(),
	}
	return resource
}

// Parse parses an interface{} object into a struct for this resource type
func (h *SyntheticMonitoringHandler) Parse(i interface{}) (grizzly.Resources, error) {
	resources := grizzly.Resources{}
	msi := i.(map[string]interface{})
	for k, v := range msi {
		check := Check{}
		err := mapstructure.Decode(v, &check)
		if err != nil {
			return nil, err
		}
		resource := h.newCheckResource(k, check)
		key := resource.Key()
		resources[key] = resource
	}
	return resources, nil
}

// Unprepare removes unnecessary elements from a remote resource ready for presentation/comparison
func (h *SyntheticMonitoringHandler) Unprepare(resource grizzly.Resource) *grizzly.Resource {
	delete(resource.Detail, "tenantId")
	delete(resource.Detail, "id")
	delete(resource.Detail, "modified")
	delete(resource.Detail, "created")
	return &resource
}

// Prepare gets a resource ready for dispatch to the remote endpoint
func (h *SyntheticMonitoringHandler) Prepare(existing, resource grizzly.Resource) *grizzly.Resource {
	resource.Detail["tenantId"] = existing.Detail["tenantId"]
	resource.Detail["id"] = existing.Detail["id"]
	return &resource
}

// GetByUID retrieves JSON for a resource from an endpoint, by UID
func (h *SyntheticMonitoringHandler) GetByUID(UID string) (*grizzly.Resource, error) {
	check, err := getRemoteCheck(UID)
	if err != nil {
		return nil, fmt.Errorf("Error retrieving check %s: %v", UID, err)
	}
	resource := h.newCheckResource("", *check)
	return &resource, nil
}

// GetRepresentation renders a resource as JSON or YAML as appropriate
func (h *SyntheticMonitoringHandler) GetRepresentation(uid string, resource grizzly.Resource) (string, error) {
	j, err := json.MarshalIndent(resource.Detail, "", "  ")
	if err != nil {
		return "", err
	}
	return string(j), nil
}

// GetRemoteRepresentation retrieves a datasource as JSON
func (h *SyntheticMonitoringHandler) GetRemoteRepresentation(uid string) (string, error) {
	check, err := getRemoteCheck(uid)
	if err != nil {
		return "", err
	}
	return check.toJSON()
}

// GetRemote retrieves a datasource as a Resource
func (h *SyntheticMonitoringHandler) GetRemote(uid string) (*grizzly.Resource, error) {
	check, err := getRemoteCheck(uid)
	if err != nil {
		return nil, err
	}
	resource := h.newCheckResource("", *check)
	return &resource, nil
}

// Add adds a new check to the SyntheticMonitoring endpoint
func (h *SyntheticMonitoringHandler) Add(resource grizzly.Resource) error {
	url := getURL("api/v1/check/add")
	return postCheck(url, Check(resource.Detail))
}

// Update pushes an updated check to the SyntheticMonitoring endpoing
func (h *SyntheticMonitoringHandler) Update(existing, resource grizzly.Resource) error {
	check := Check(resource.Detail)
	url := getURL("api/v1/check/update")
	return postCheck(url, check)
}

// Preview renders Jsonnet then pushes them to the endpoint if previews are possible
func (h *SyntheticMonitoringHandler) Preview(resource grizzly.Resource, opts *grizzly.PreviewOpts) error {
	return grizzly.ErrNotImplemented
}

///////////////////////////////////////////////////////////////////////////

// getRemoteCheck retrieves a check object from SM
func getRemoteCheck(uid string) (*Check, error) {
	url := getURL("api/v1/check/list")
	authToken, err := getAuthToken()
	if err != nil {
		return nil, err
	}
	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	req.Header.Add("Authorization", "Bearer "+authToken)
	req.Header.Add("Content-type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNotFound:
		return nil, grizzly.ErrNotFound
	default:
		if resp.StatusCode >= 400 {
			return nil, errors.New(resp.Status)
		}
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var checks []Check
	if err := json.Unmarshal(data, &checks); err != nil {
		return nil, APIErr{err, data}
	}
	probes, err := getProbeList()
	if err != nil {
		return nil, err
	}
	for _, check := range checks {
		if check.UID() == uid {
			probeNames := []string{}
			for _, probe := range check["probes"].([]interface{}) {
				probeID := int(probe.(float64))
				name := probes.ByID[probeID].Name
				probeNames = append(probeNames, name)
			}
			check["probes"] = probeNames
			return &check, nil
		}
	}
	return nil, grizzly.ErrNotFound
}

func postCheck(url string, check Check) error {
	checkJSON, err := check.toJSON()
	if err != nil {
		return err
	}

	client := &http.Client{}
	accessToken, err := getAuthToken()
	if err != nil {
		return err
	}
	req, err := http.NewRequest("POST", url, bytes.NewBufferString(checkJSON))
	if err != nil {
		return err
	}
	req.Header.Add("Authorization", "Bearer "+accessToken)
	req.Header.Add("Content-type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		return err
	}

	switch resp.StatusCode {
	case http.StatusOK:
		break
	default:
		return fmt.Errorf("Non-200 response from Grafana Synthetic Monitoring while applying '%s': %s", resp.Status, check.UID())
	}
	return nil
}

// Probe defines the properties of a single SM Probe
type Probe struct {
	ID       int    `json:"id"`
	TenantID int    `json:"tenantId"`
	Name     string `json:"name"`
	Region   string `json:"region"`
	Public   bool   `json:"public"`
	Online   bool   `json:"online"`
}

// Probes allows accessing Probe objects by ID and by name
type Probes struct {
	ByID   map[int]Probe
	ByName map[string]Probe
}

// getRemoteCheck retrieves a check object from SM
func getProbeList() (*Probes, error) {
	url := getURL("api/v1/probe/list")
	authToken, err := getAuthToken()
	if err != nil {
		return nil, err
	}
	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	req.Header.Add("Authorization", "Bearer "+authToken)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNotFound:
		return nil, grizzly.ErrNotFound
	default:
		if resp.StatusCode >= 400 {
			return nil, errors.New(resp.Status)
		}
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	probeList := []Probe{}
	if err := json.Unmarshal(data, &probeList); err != nil {
		return nil, APIErr{err, data}
	}
	probes := Probes{
		ByID:   map[int]Probe{},
		ByName: map[string]Probe{},
	}
	for _, probe := range probeList {
		if probe.Online && probe.Public {
			probes.ByID[probe.ID] = probe
			probes.ByName[probe.Name] = probe
		}
	}
	return &probes, nil
}

// Check encapsulates a check
type Check map[string]interface{}

// UID retrieves the UID from a check
func (c *Check) UID() string {
	job, ok := (*c)["job"]
	if !ok {
		return "X"
	}
	settings, ok := (*c)["settings"]
	if !ok {
		return "Y"
	}
	for typ := range settings.(map[string]interface{}) {
		return fmt.Sprintf("%s-%s", typ, job)
	}
	return "NIL"
}

// toJSON returns JSON for a datasource
func (c *Check) toJSON() (string, error) {
	probes, err := getProbeList()
	if err != nil {
		return "", err
	}
	probeIDs := []int{}
	for _, probe := range (*c)["probes"].([]interface{}) {
		probeName := probe.(string)
		id := probes.ByName[probeName].ID
		probeIDs = append(probeIDs, id)
	}
	(*c)["probes"] = probeIDs

	j, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return "", err
	}
	return string(j), nil
}

func getURL(path string) string {
	return fmt.Sprintf(smURL, path)
}

func getAuthToken() (string, error) {
	url := getURL("api/v1/register/init")
	apiToken := os.Getenv("GRAFANA_SM_TOKEN")
	authRequest := fmt.Sprintf(`{"apiToken":"%s"}`, apiToken)

	resp, err := http.Post(url, "application/json", bytes.NewBufferString(authRequest))
	if err != nil {
		return "", err
	} else if resp.StatusCode >= 400 {
		return "", fmt.Errorf("%d response while authenticating", resp.StatusCode)
	}
	type AuthResponse struct {
		AccessToken string `json:"accessToken"`
	}
	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	authResponse := AuthResponse{}
	if err := json.Unmarshal(data, &authResponse); err != nil {
		return "", APIErr{err, data}

	}
	return authResponse.AccessToken, nil
}
